class SCRIPT:
    class GUI:
        class RelicText:
            def __init__(self, text, color="grey"):
                self.rectangle = Main.relic_engine.create_rectangle(
                    int(Camera.cam_x // 4),
                    int(Main.y//1.5),
                    int(Camera.cam_x * 1.75),
                    int(Main.y),
                    fill=color,
                )
                self.text = Main.relic_engine.create_text(
                    Camera.cam_x,
                    Main.y//1.25,
                    font=("", 25)
                )
                self.write_text(text, 0)
                Main.relic_engine.unbind_all()
                Main.windows.bind("<Return>", self.finish)
                Main.relic_engine.reload_function["Relic-Gui-Text"] = self.reload
                Main.relic_engine.run()
        
            def write_text(self, text, number):
                if number <= len(list(text)):
                    Main.relic_engine.itemconfigure(self.text, text="".join(list(text)[0:number]))
                    Main.windows.after(50, lambda text_a=text, number_a=number+1: self.write_text(text_a, number_a))
        
            def finish(self, *evt):
                Main.relic_engine.delete(self.rectangle, self.text)
                Main.windows.unbind("<Return>")
                del Main.relic_engine.reload_function["Relic-Gui-Text"]
                Main.relic_engine.rebind_all()
                Main.relic_engine.turn = False
        
            def reload(self, *evt):
                Main.relic_engine.coords(
                    self.rectangle,
                    int(Camera.cam_x // 4),
                    int(Main.y//1.5),
                    int(Camera.cam_x * 1.75),
                    int(Main.y)
                )
                Main.relic_engine.coords(self.text, Camera.cam_x, Main.y//1.25)
        def RelicEntry(self):
            class Entry:
                def __init__(self):
                    self.entry = StringVar()
        
                def place(self):
                    self.rectangle = Main.relic_engine.create_rectangle(
                        int(Camera.cam_x - Camera.cam_x // 1.25),
                        int(Camera.cam_y - Camera.cam_y // 2),
                        int(Camera.cam_x + Camera.cam_x // 1.25),
                        int(Camera.cam_y + Camera.cam_y // 2),
                        fill="blue"
                    )
                    self.label = Main.relic_engine.create_text(
                        Camera.cam_x,
                        Camera.cam_y,
                        font=("", 25)
                    )
                    Main.relic_engine.reload_function["Relic-Gui-Entry"] = self.reload
                    Main.relic_engine.unbind_all()
                    Main.windows.bind("<Key>", self.enter_key)
                    Main.relic_engine.run()
                    return self.entry.get()
        
                def enter_key(self, evt):
                    if evt.keysym == "Return":
                        self.finish()
                    else:
                        if evt.keysym == "BackSpace":
                            r = list(self.entry.get())
                            del r[-1]
                            self.entry.set("".join(r))
                        else:
                            self.entry.set(self.entry.get() + str(evt.char))
                    Main.relic_engine.itemconfigure(self.label, text=self.entry.get())
        
                def finish(self):
                    Main.relic_engine.delete(self.rectangle, self.label)
                    del Main.relic_engine.reload_function["Relic-Gui-Entry"]
                    Main.windows.unbind("<Key>")
                    Main.relic_engine.rebind_all()
                    Main.relic_engine.stop()
        
                def reload(self, *evt):
                    Main.relic_engine.coords(
                        self.rectangle,
                        int(Camera.cam_x - Camera.cam_x // 1.25),
                        int(Camera.cam_y - Camera.cam_y // 2),
                        int(Camera.cam_x + Camera.cam_x // 1.25),
                        int(Camera.cam_y + Camera.cam_y // 2),
                    )
                    Main.relic_engine.coords(
                        self.label, Camera.cam_x, Camera.cam_y
                    )
            return Entry().place()
        def __init__(self):
            pass
    class THREED:
        
        class Axis3:
            def __init__(self, x=0, y=0, z=0):
                self.x = x
                self.y = y
                self.z = z
        
        
        class Axis2:
            def __init__(self, x=0, y=0):
                self.x = x
                self.y = y
        """
        Relic_Engine 3D-Script
        Test for 3D Object
        """
        
        
        class Face:
            def __init__(self, vertices):
                self.a, self.b, self.c, self.color = vertices
        
        
        class Object:
            def __init__(self, point, triangles, vertex, face):
                self.master = Main.relic_engine
                self.data_object = []
                self.point = []
                self.distance = 6
                self.scale = 100
                self.Vertex = vertex
                self.Face = face
                self.writePoints(point)
                self.writeTriangles(triangles)
        
            def writePoints(self, points):
                self.points = []
                for point in points:
                    self.points.append(self.Vertex(point))
        
            def writeTriangles(self, triangles):
                self.triangles = []
                for triangle in triangles:
                    if len(triangle) != 4:
                        triangle.append('gray')
                    self.triangles.append(self.Face(triangle))
        
            def createTriangle(self, points, color):
                a, b, c = points[0], points[1], points[2]
                # create coordinates starting in center of screen
                coord = [a[0] + self.zero[0],
                         a[1] + self.zero[1],
                         b[0] + self.zero[0],
                         b[1] + self.zero[1],
                         c[0] + self.zero[0],
                         c[1] + self.zero[1]]
                # draw triangle on screen
                self.data_object.append(self.master.create_polygon(coord, fill=color, outline="black"))
        
            def createLine(self, points, color):
                a, b = points[0], points[1]
                self.data_object.append(self.master.create_line(a[0], a[1], b[0], b[1], fill=color, arrow=tkinter.BOTH))
                return self.data_object[-1]
        
            def clear(self):
                # clear display
                self.master.delete(*self.data_object)
                del self.data_object
                self.data_object = []
        
            def delete(self, item):
                self.master.delete(item)
                return None
        
            def after(self, time, function):
                self.master.after(time, function)
        
            def render(self):
                self.zero = [int(Main.x / 2), int(Main.y / 2)]
                self.flattened = []
                for point in self.points:
                    self.flattened.append(point.flatten(self.scale, self.distance))
        
                triangles = []
                for triangle in self.triangles:
                    avg_z = -(self.points[triangle.a].point.z + self.points[triangle.b].point.z +
                              self.points[triangle.c].point.z) / 3
                    triangles.append((self.flattened[triangle.a], self.flattened[triangle.b], self.flattened[triangle.c],
                                      triangle.color, avg_z))
        
                # sort triangles from furthest back to closest
                triangles = sorted(triangles, key=lambda x: x[4])
        
                # draw triangles
                for triangle in triangles:
                    self.createTriangle(triangle[0:3], triangle[3])
        
            def rotate(self, axis, angle):
                # rotate model around axis
                for point in self.points:
                    point.rotate(axis, angle)
        class Vertex:
            def __init__(self, point, axis_3):
                self.point = axis_3(*point)
                self.Axis3 = axis_3
        
            def flatten(self, scale, distance):
                # calculate 2D coordinates from 3D point
                projected_y = int(((self.point.y * distance) / (self.point.z + distance)) * scale)
                projected_x = int(((self.point.x * distance) / (self.point.z + distance)) * scale)
                return [projected_x, projected_y]
        
            def rotate(self, axis, angle):
                angle = angle / 450 * 180 / math.pi
                if axis == 'z':
                    new_x = self.point.x * math.cos(angle) - self.point.y * math.sin(angle)
                    new_y = self.point.y * math.cos(angle) + self.point.x * math.sin(angle)
                    new_z = self.point.z
                elif axis == 'x':
                    new_y = self.point.y * math.cos(angle) - self.point.z * math.sin(angle)
                    new_z = self.point.z * math.cos(angle) + self.point.y * math.sin(angle)
                    new_x = self.point.x
                elif axis == 'y':
                    new_x = self.point.x * math.cos(angle) - self.point.z * math.sin(angle)
                    new_z = self.point.z * math.cos(angle) + self.point.x * math.sin(angle)
                    new_y = self.point.y
                else:
                    raise ValueError('invalid rotation axis')
                del self.point
                self.point = self.Axis3(new_x, new_y, new_z)
        
            def move(self, axis, value):
                if axis == 'x':
                    self.point.x += value
                elif axis == 'y':
                    self.point.y += value
                elif axis == 'z':
                    self.point.z += value
                else:
                    raise ValueError('Invalid movement axis')
        def load_object(self, point, triangle):
            return self.Object(point, triangle, self.load_vertex, self.Face)
        
        
        def load_vertex(self, point):
            return self.Vertex(point, self.Axis3)
        def __init__(self):
            pass
    def __init__(self):
        self.Gui= self.GUI()
        self.ThreeD= self.THREED()